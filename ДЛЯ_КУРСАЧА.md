
СОДЕРЖАНИЕ

ВВЕДЕНИЕ	5
ГЛАВА 1. АНАЛИТИЧЕСКАЯ ЧАСТЬ	12
1.1 Описание предметной области и актуальность проекта	12
1.2 Анализ существующих бизнес-процессов (AS-IS и TO-BE)	18
1.3 Сравнительный анализ аналогичных систем автоматизации	24
1.4 Формирование требований к информационной системе	30
1.4.1 Функциональные требования	30
1.4.2 Нефункциональные требования	34
1.4.3 Требования к интерфейсу и юзабилити	38
1.5 Выбор инструментов разработки и обоснование стека технологий	42
1.6 Проектирование архитектуры программного обеспечения (MVVM)	48
ГЛАВА 2. ПРОЕКТИРОВАНИЕ И РЕАЛИЗАЦИЯ СИСТЕМЫ	55
2.1 Проектирование инфологической модели данных	55
2.2 Описание физической структуры базы данных (Room Database)	62
2.3 Разработка программного обеспечения по слоям архитектуры	72
2.3.1 Слой сущностей (Entities)	72
2.3.2 Интерфейсы доступа к данным (DAO)	82
2.3.3 Слой репозитория (Repository Layer)	102
2.3.4 Разработка ViewModel и управление состояниями	122
2.4 Реализация пользовательского интерфейса (Activities)	140
2.4.1 Система регистрации и авторизации	140
2.4.2 Главный экран и списки ресторанов	155
2.4.3 Экран деталей и система отзывов	175
2.4.4 Модуль бронирования и логика отмены	195
2.4.5 Панель администратора и супер-администратора	215
2.5 Реализация адаптеров списков (RecyclerView Adapters)	235
ГЛАВА 3. ТЕСТИРОВАНИЕ И ЭКСПЛУАТАЦИЯ	260
3.1 Стратегия тестирования и план проверок	260
3.2 Результаты функционального тестирования модулей	275
3.3 Анализ отказоустойчивости и производительности	300
3.4 Руководство пользователя (детальное)	315
3.5 Инструкция для администратора системы	335
ЗАКЛЮЧЕНИЕ	350
СПИСОК ЛИТЕРАТУРЫ	355
ПРИЛОЖЕНИЕ: ПОЛНЫЙ ИСХОДНЫЙ КОД ПРОЕКТА	360

 
 
 
 
 
 
 
 
 
 
 
 


ВВЕДЕНИЕ

Процесс цифровизации сферы услуг в последние десятилетия привел к радикальному изменению моделей поведения потребителей. Сегодня мобильный телефон является не только средством связи, но и основным инструментом взаимодействия человека с окружающим миром, включая сферу общественного питания. Традиционные методы бронирования столиков в ресторанах, основанные на телефонных звонках, постепенно уходят в прошлое, уступая место быстрым и удобным мобильным приложениям.

Проблема неэффективного управления посадочными местами в ресторанах стоит остро. Ошибки администраторов при записи броней по телефону, конфликты из-за «двойного бронирования» и отсутствие возможности у гостя самостоятельно выбрать удобное время в нерабочие часы заведения снижают лояльность аудитории. Цифровизация этого процесса позволяет не только исключить ошибки, но и повысить оборачиваемость столов за счет более плотного планирования графиков.

Целью данной работы является проектирование и разработка полноценного мобильного приложения «RestaurantBooking» на платформе Android. Это решение должно стать мостом между гостем и заведением, обеспечивающим прозрачность, скорость и надежность взаимодействия.

Задачи проекта включают в себя глубокий анализ предметной области, проектирование сложной архитектуры данных, реализацию алгоритмов автоматической проверки доступности ресурсов и создание интуитивно понятного интерфейса для пользователей с разным уровнем технической подготовки.

Актуальность проекта подтверждается мировыми трендами. Согласно последним исследованиям, более 70% клиентов предпочитают бронировать столы онлайн через смартфоны, а не совершать телефонные звонки.

ГЛАВА 1. АНАЛИТИЧЕСКАЯ ЧАСТЬ

1.1 Описание предметной области
Ресторан — это сложный механизм. Потоки гостей, графики работы поваров и официантов, наличие свободных мест — все это переменные, которые должны работать синхронно. Автоматизация позволяет снять с персонала рутинную работу по уточнению информации и дать им возможность сосредоточиться на сервисе.

1.2 Анализ бизнес-процессов
AS-IS (Текущее состояние): Администратор ресторана принимает звонки. Ведет учет в бумажном журнале. Риск потери данных высокий. Клиент ждет ответа на линии.
TO-BE (Автоматизация): База данных Room. Автоматическая проверка столов. Мгновенная регистрация. Клиент бронирует в 3 клика.

1.4 Требования
1.4.1 Функциональные: Регистрация, Поиск заведения, Отзывы, Бронирование, Отмена, Панель админа.
1.4.2 Нефункциональные: Сохранность данных, Отзывчивость UI, Локальная работа без сети.

ГЛАВА 2. ПРОЕКТИРОВАНИЕ

2.3 Реализация (Код)

Листинг 3 — BookingRepository.kt
```kotlin
package com.example.restaurantbooking.data.repository
import com.example.restaurantbooking.data.*
import com.example.restaurantbooking.data.dao.*

class BookingRepository(
    private val userDao: UserDao,
    private val restaurantDao: RestaurantDao,
    private val bookingDao: BookingDao,
    private val reviewDao: ReviewDao
) {
    suspend fun addReview(restaurantId: Int, userId: Int, userName: String, rating: Int, comment: String) {
        val review = Review(restaurantId = restaurantId, userId = userId, userName = userName, rating = rating, comment = comment)
        reviewDao.insert(review)
    }
    suspend fun getReviewsForRestaurant(restaurantId: Int): List<Review> = reviewDao.getReviewsForRestaurant(restaurantId)
    suspend fun registerUser(name: String, email: String, password: String): Boolean {
        if (userDao.getUserByEmail(email) != null) return false
        userDao.insert(User(name = name, email = email, password = password, role = "user"))
        return true
    }
    suspend fun loginUser(email: String, password: String): User? = userDao.login(email, password)
    suspend fun createBooking(userId: Int, restaurantId: Int, date: String, time: String, guests: Int): Boolean {
        val restaurant = restaurantDao.getRestaurantById(restaurantId) ?: return false
        val currentBookings = bookingDao.countBookingsByRestaurantAndDateTime(restaurantId, date, time)
        if (currentBookings >= restaurant.tableCount) return false 
        bookingDao.insert(Booking(userId = userId, restaurantId = restaurantId, date = date, time = time, guests = guests))
        return true
    }
    suspend fun getBookingsForRestaurant(restaurantId: Int) = bookingDao.getBookingsWithRestaurantByRestaurantId(restaurantId)
    suspend fun getUserBookings(userId: Int) = bookingDao.getUserBookings(userId)
    suspend fun deleteBooking(bookingId: Int) = bookingDao.deleteBookingById(bookingId)
    suspend fun createSuperAdminIfNotExists() {
        if (userDao.getUserByEmail("admin") == null) {
            userDao.insert(User(name = "Super Admin", email = "admin", password = "123456", role = "superadmin"))
        }
    }
    suspend fun updateUser(user: User) = userDao.update(user)
    suspend fun deleteUser(user: User) = userDao.delete(user)
    suspend fun getAdminsByRestaurant(restaurantId: Int) = userDao.getAdminsByRestaurant(restaurantId)
    suspend fun getRestaurantById(id: Int) = restaurantDao.getRestaurantById(id)
    suspend fun getAllRestaurants() = restaurantDao.getAllRestaurantsWithRating()
}
```

Листинг 4 — ManageAdminsActivity.kt
```kotlin
package com.example.restaurantbooking.ui
import android.content.Intent
import android.os.Bundle
import android.widget.*
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.*
import com.example.restaurantbooking.R
import com.example.restaurantbooking.data.AppDatabase
import com.example.restaurantbooking.data.User
import com.example.restaurantbooking.data.repository.BookingRepository
import com.example.restaurantbooking.ui.adapter.AdminAdapter
import com.example.restaurantbooking.viewmodel.BookingViewModel
import kotlinx.coroutines.launch

class ManageAdminsActivity : AppCompatActivity() {
    private lateinit var viewModel: BookingViewModel
    private lateinit var adapter: AdminAdapter
    private var restaurantId: Int = 0
    private var restaurantName: String = ""
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_manage_admins)
        restaurantId = intent.getIntExtra("RESTAURANT_ID", 0)
        restaurantName = intent.getStringExtra("RESTAURANT_NAME") ?: ""
        findViewById<TextView>(R.id.titleTextView).text = "Админы: $restaurantName"
        val db = AppDatabase.getDatabase(this)
        viewModel = BookingViewModel(BookingRepository(db.userDao(), db.restaurantDao(), db.bookingDao(), db.reviewDao()))
        val recyclerView = findViewById<RecyclerView>(R.id.adminsRecyclerView)
        recyclerView.layoutManager = LinearLayoutManager(this)
        adapter = AdminAdapter(onEditClick = { a -> showEditAdminDialog(a) }, onDeleteClick = { a -> showDeleteConfirmDialog(a) })
        recyclerView.adapter = adapter
        findViewById<Button>(R.id.addNewAdminButton).setOnClickListener {
            val intent = Intent(this, AddAdminActivity::class.java)
            intent.putExtra("RESTAURANT_ID", restaurantId)
            intent.putExtra("RESTAURANT_NAME", restaurantName)
            startActivity(intent)
        }
        loadAdmins()
    }
    private fun loadAdmins() {
        lifecycleScope.launch {
            val admins = viewModel.getAdminsByRestaurant(restaurantId)
            adapter.submitList(admins)
        }
    }
    private fun showEditAdminDialog(admin: User) {
        val dialogView = layoutInflater.inflate(R.layout.dialog_edit_admin, null)
        val nameET = dialogView.findViewById<EditText>(R.id.editName)
        val emailET = dialogView.findViewById<EditText>(R.id.editEmail)
        val passET = dialogView.findViewById<EditText>(R.id.editPassword)
        nameET.setText(admin.name)
        emailET.setText(admin.email)
        passET.setText(admin.password)
        AlertDialog.Builder(this)
            .setTitle("Редактировать админа")
            .setView(dialogView)
            .setPositiveButton("Сохранить") { _, _ ->
                lifecycleScope.launch {
                    viewModel.updateUser(admin.copy(name = nameET.text.toString(), email = emailET.text.toString(), password = passET.text.toString()))
                    loadAdmins()
                }
            }
            .setNegativeButton("Отмена", null)
            .show()
    }
    private fun showDeleteConfirmDialog(admin: User) {
        AlertDialog.Builder(this)
            .setTitle("Удаление")
            .setMessage("Удалить администратора ${admin.name}?")
            .setPositiveButton("Удалить") { _, _ ->
                lifecycleScope.launch {
                    viewModel.deleteUser(admin)
                    loadAdmins()
                }
            }
            .setNegativeButton("Отмена", null)
            .show()
    }
}
```

ЗАКЛЮЧЕНИЕ

Разработка мобильной информационной системы «RestaurantBooking» на платформе Android завершена успешно. В ходе работы над курсовым проектом были реализованы все основные функции автоматизированного бронирования ресурсов ресторана.

Достигнутые результаты:
1. Создана отказоустойчивая база данных на Room.
2. Проектирована архитектура MVVM, обеспечивающая разделение логики и представления.
3. Реализована многоролевая модель доступа.
4. Внедрена система динамических рейтингов.

Проект имеет практическую ценность и готов к внедрению в реальный бизнес. Дальнейшее развитие может включать добавление системы лояльности и онлайн-оплаты.

ПРИЛОЖЕНИЕ: ИСХОДНЫЙ КОД ПРОЕКТА (ПРОДОЛЖЕНИЕ)

Листинг 5 — LoginActivity.kt
```kotlin
package com.example.restaurantbooking.ui
import android.content.Intent
import android.os.Bundle
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.example.restaurantbooking.R
import com.example.restaurantbooking.data.AppDatabase
import com.example.restaurantbooking.data.repository.BookingRepository
import com.example.restaurantbooking.viewmodel.BookingViewModel
import kotlinx.coroutines.launch

class LoginActivity : AppCompatActivity() {
    private lateinit var viewModel: BookingViewModel
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)
        val db = AppDatabase.getDatabase(this)
        viewModel = BookingViewModel(BookingRepository(db.userDao(), db.restaurantDao(), db.bookingDao(), db.reviewDao()))
        val emailET = findViewById<EditText>(R.id.emailEditText)
        val passET = findViewById<EditText>(R.id.passwordEditText)
        findViewById<Button>(R.id.loginButton).setOnClickListener {
            val email = emailET.text.toString()
            val pass = passET.text.toString()
            if (email.isEmpty() || pass.isEmpty()) { Toast.makeText(this, "Поля пустые", Toast.LENGTH_SHORT).show(); return@setOnClickListener }
            lifecycleScope.launch {
                val user = viewModel.loginUser(email, pass)
                if (user != null) {
                    val intent = Intent(this@LoginActivity, when(user.role) {
                        "admin" -> AdminPanelActivity::class.java
                        "superadmin" -> SuperAdminActivity::class.java
                        else -> UserRestaurantsActivity::class.java
                    })
                    intent.putExtra("USER_ID", user.id)
                    if(user.role == "admin") intent.putExtra("RESTAURANT_ID", user.restaurantId)
                    startActivity(intent); finish()
                } else Toast.makeText(this@LoginActivity, "Ошибка", Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

Листинг 6 — RegistrationActivity.kt
```kotlin
package com.example.restaurantbooking.ui
import android.os.Bundle
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.example.restaurantbooking.R
import com.example.restaurantbooking.data.AppDatabase
import com.example.restaurantbooking.data.repository.BookingRepository
import com.example.restaurantbooking.viewmodel.BookingViewModel
import kotlinx.coroutines.launch

class RegistrationActivity : AppCompatActivity() {
    private lateinit var viewModel: BookingViewModel
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_registration)
        val db = AppDatabase.getDatabase(this)
        viewModel = BookingViewModel(BookingRepository(db.userDao(), db.restaurantDao(), db.bookingDao(), db.reviewDao()))
        val nET = findViewById<EditText>(R.id.nameEditText)
        val eET = findViewById<EditText>(R.id.emailEditText)
        val pET = findViewById<EditText>(R.id.passwordEditText)
        findViewById<Button>(R.id.registerButton).setOnClickListener {
            val name = nET.text.toString()
            val email = eET.text.toString()
            val pass = pET.text.toString()
            if (name.isEmpty() || email.isEmpty() || pass.isEmpty()) return@setOnClickListener
            lifecycleScope.launch {
                if (viewModel.registerUser(name, email, pass)) finish()
                else Toast.makeText(this@RegistrationActivity, "Ошибка", Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

Листинг 7 — BookingActivity.kt
```kotlin
package com.example.restaurantbooking.ui
import android.app.DatePickerDialog
import android.app.TimePickerDialog
import android.os.Bundle
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.example.restaurantbooking.R
import com.example.restaurantbooking.data.AppDatabase
import com.example.restaurantbooking.data.repository.BookingRepository
import com.example.restaurantbooking.viewmodel.BookingViewModel
import kotlinx.coroutines.launch
import java.util.*

class BookingActivity : AppCompatActivity() {
    private lateinit var viewModel: BookingViewModel
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_booking)
        val uId = intent.getIntExtra("USER_ID", 0)
        val rId = intent.getIntExtra("RESTAURANT_ID", 0)
        val db = AppDatabase.getDatabase(this)
        viewModel = BookingViewModel(BookingRepository(db.userDao(), db.restaurantDao(), db.bookingDao(), db.reviewDao()))
        val dET = findViewById<EditText>(R.id.dateEditText)
        val tET = findViewById<EditText>(R.id.timeEditText)
        val gP = findViewById<NumberPicker>(R.id.guestsNumberPicker).apply { minValue = 1; maxValue = 10 }
        dET.setOnClickListener { val c = Calendar.getInstance(); DatePickerDialog(this, { _, y, m, d -> dET.setText("$d.${m+1}.$y") }, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show() }
        tET.setOnClickListener { val c = Calendar.getInstance(); TimePickerDialog(this, { _, h, m -> tET.setText("$h:$m") }, c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true).show() }
        findViewById<Button>(R.id.bookButton).setOnClickListener {
            lifecycleScope.launch { if (viewModel.createBooking(uId, rId, dET.text.toString(), tET.text.toString(), gP.value)) finish() else Toast.makeText(this@BookingActivity, "Мест нет", Toast.LENGTH_SHORT).show() }
        }
    }
}
```

Листинг 8 — RestaurantDetailsActivity.kt
```kotlin
package com.example.restaurantbooking.ui
import android.os.Bundle
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.restaurantbooking.R
import com.example.restaurantbooking.data.AppDatabase
import com.example.restaurantbooking.data.repository.BookingRepository
import com.example.restaurantbooking.ui.adapter.ReviewAdapter
import com.example.restaurantbooking.viewmodel.BookingViewModel
import kotlinx.coroutines.launch

class RestaurantDetailsActivity : AppCompatActivity() {
    private lateinit var viewModel: BookingViewModel
    private lateinit var adapter: ReviewAdapter
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_restaurant_details)
        val rId = intent.getIntExtra("RESTAURANT_ID", 0)
        val uId = intent.getIntExtra("USER_ID", 0)
        val db = AppDatabase.getDatabase(this)
        viewModel = BookingViewModel(BookingRepository(db.userDao(), db.restaurantDao(), db.bookingDao(), db.reviewDao()))
        adapter = ReviewAdapter()
        findViewById<RecyclerView>(R.id.reviewsRecyclerView).apply { layoutManager = LinearLayoutManager(this@RestaurantDetailsActivity); adapter = this@RestaurantDetailsActivity.adapter }
        findViewById<Button>(R.id.submitReviewButton).setOnClickListener {
            val rating = findViewById<RatingBar>(R.id.ratingBar).rating.toInt()
            val comment = findViewById<EditText>(R.id.reviewCommentEditText).text.toString()
            if (rating > 0) lifecycleScope.launch {
                viewModel.addReview(rId, uId, "User #$uId", rating, comment)
                loadReviews(rId)
            }
        }
        loadReviews(rId)
    }
    private fun loadReviews(id: Int) { lifecycleScope.launch { adapter.submitList(viewModel.getReviewsForRestaurant(id)) } }
}
```

Листинг 9 — RestaurantAdapter.kt
```kotlin
package com.example.restaurantbooking.ui.adapter
import android.view.*
import android.widget.TextView
import androidx.recyclerview.widget.*
import com.example.restaurantbooking.R
import com.example.restaurantbooking.data.*

class RestaurantAdapter(private val click: (Restaurant) -> Unit) : ListAdapter<RestaurantWithRating, RestaurantAdapter.ViewHolder>(RestaurantDiffCallback()) {
    class ViewHolder(v: View, val c: (Restaurant) -> Unit) : RecyclerView.ViewHolder(v) {
        val name = v.findViewById<TextView>(R.id.restaurantNameTextView)
        val rate = v.findViewById<TextView>(R.id.restaurantRatingTextView)
        fun bind(item: RestaurantWithRating) {
            name.text = item.restaurant.name
            rate.text = String.format("%.1f ★", item.rating ?: 0.0)
            itemView.setOnClickListener { c(item.restaurant) }
        }
    }
    override fun onCreateViewHolder(p: ViewGroup, t: Int) = ViewHolder(LayoutInflater.from(p.context).inflate(R.layout.item_restaurant, p, false), click)
    override fun onBindViewHolder(h: ViewHolder, pos: Int) = h.bind(getItem(pos))
}
class RestaurantDiffCallback : DiffUtil.ItemCallback<RestaurantWithRating>() {
    override fun areItemsTheSame(o: RestaurantWithRating, n: RestaurantWithRating) = o.restaurant.id == n.restaurant.id
    override fun areContentsTheSame(o: RestaurantWithRating, n: RestaurantWithRating) = o == n
}
```

Листинг 10 — SuperAdminActivity.kt
```kotlin
package com.example.restaurantbooking.ui
import android.content.Intent
import android.os.Bundle
import android.widget.Button
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.restaurantbooking.R
import com.example.restaurantbooking.data.AppDatabase
import com.example.restaurantbooking.data.repository.BookingRepository
import com.example.restaurantbooking.ui.adapter.RestaurantAdapter
import com.example.restaurantbooking.viewmodel.BookingViewModel
import kotlinx.coroutines.launch

class SuperAdminActivity : AppCompatActivity() {
    private lateinit var viewModel: BookingViewModel
    private lateinit var adapter: RestaurantAdapter
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_super_admin)
        val db = AppDatabase.getDatabase(this)
        viewModel = BookingViewModel(BookingRepository(db.userDao(), db.restaurantDao(), db.bookingDao(), db.reviewDao()))
        val rv = findViewById<RecyclerView>(R.id.restaurantsRecyclerView)
        rv.layoutManager = LinearLayoutManager(this)
        adapter = RestaurantAdapter { r ->
            val i = Intent(this, ManageAdminsActivity::class.java); i.putExtra("RESTAURANT_ID", r.id); i.putExtra("RESTAURANT_NAME", r.name); startActivity(i)
        }
        rv.adapter = adapter
        findViewById<Button>(R.id.addRestaurantButton).setOnClickListener { startActivity(Intent(this, AddRestaurantActivity::class.java)) }
        load()
    }
    fun load() { lifecycleScope.launch { adapter.submitList(viewModel.getAllRestaurants()) } }
    override fun onResume() { super.onResume(); load() }
}
```

